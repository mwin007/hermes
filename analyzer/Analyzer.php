<?php
require_once dirname(__FILE__) . '/../inc/HermesHelper.php';
require_once dirname(__FILE__) . '/ValidatorContext.php';
require_once dirname(__FILE__) . '/Abstract/Validator.php';
foreach (glob(dirname(__FILE__) . "/Abstract/*.php") as $filename) {
    require_once $filename;
}
foreach (glob(dirname(__FILE__) . "/lexical/*.php") as $filename) {
    require_once $filename;
}
foreach (glob(dirname(__FILE__) . "/semantic/*.php") as $filename) {
    require_once $filename;
}

/**
 * In charge of instanciate all the validators for each analysis phase.
 * Allow to perform lexical and semantic analysis of a given CSV.
 *
 */
class Analyzer {

    const LEXICAL = 'lexical';
    const SEMANTIC = 'semantic';

    /**
     * Allowed profiles
     */
    private static $_PROFILES = array('import', 'update', 'super', 'import_category', 'update_category');

    /**
     * List of custom sites (= database name) where the sku must be generated by adding the prefix of the product brand
     * The names correspond with the database name of the projects
     * TODO: Put this on a .ini config file or add an option in magmi config web to enable/disable custom site.
     */
    public static $_CUSTOM_SITES = array('bcnfashion', 'clickonfashion', 'alimentati', 'stylebcn', 'stylebarcelona');

    private $_validators;
    private $_columnIndexes;
    private $_rows;
    private $_errors;
    private $_results;
    private $_brandIndex;
    private $_parsedFirstLine;
    private $_requiredFields;
    private $_profile;
    private $_newCategories;
    private $_skusImport;
    private $_dbConfig;
    private $_isActiveSCModule;
    private $_isActiveACModule;
    private $_customSite;

    /**
     * Initialize variables and load DB config data from magento.
     * Set a flag if the module simple-configurables is present for the current project
     *
     * @param $required array of required fields for current analysis
     * @param $profile string allowed values: import|upload|super
     * @param $newCategories bool states whether new categories should be allowed & created or not
     * @param $customDbPath bool|string full path of a custom db config xml
     * @param $skusImport array contains the skus that will be created within this importation
     */
    function __construct(array $required, $profile, $newCategories = false, $customDbPath = false, array $skusImport = array()) {
        $this->_validators = array();
        $this->_columnIndexes = array();
        $this->_rows = array();
        $this->_errors = array();
        $this->_results = '';
        $this->_brandIndex = false;
        $this->_parsedFirstLine = false;
        $this->_requiredFields = $required;
        $this->_profile = $profile;
        $this->_newCategories = $newCategories;
        $this->_skusImport = $skusImport;

        if(!in_array($profile, self::$_PROFILES)) {
            die('Unknown profile specified.');
        }

        $this->_dbConfig = HermesHelper::getMagentoDBConfig($customDbPath);
        $this->_isActiveSCModule = HermesHelper::getMagentoIsActive(HermesHelper::SC_MODULE_FILE);
        $this->_isActiveACModule = HermesHelper::getMagentoIsActive(HermesHelper::AC_MODULE_FILE);

        //Hackie way to tell if it's a custom site, by checking the database name
        //Set a global flag
        $this->_customSite = in_array($this->_dbConfig->dbname, static::$_CUSTOM_SITES);
    }

    public function getSkusImport() {
        return $this->_skusImport;
    }

    public function getProfile() {
        return $this->_profile;
    }

    /**
     * getResults Retrieve the results of the last analysis performed
     *
     * @access public
     * @return string
     */
    public function getResults() {
        return $this->_results;
    }

    /**
     * getColumnIndexes Return an array with the mapping of the indexes and the column names
     *
     * @access public
     * @return array
     */
    public function getColumnIndexes() {
        return $this->_columnIndexes;
    }

    /**
     * getRows for retriewing all the CSV rows
     *
     * @access public
     * @return array
     */
    public function getRows() {
        return $this->_rows;
    }

    /**
     * getTokens Return all tokens gathered on the lexical analysis
     *
     * @access public
     * @return array
     */
    public function getTokens($remove = true) {
        $result = array();
        foreach ($this->_validators as $key => $validator) {
            $result[$this->_columnIndexes[$key]] = ($validator->getTokens());
            if($remove) unset($this->_validators[$key]);
        }
        return $result;
    }


    /**
     * getLexicalErrors format the output of the lexical errors.
     * In order to tell the proper line, we need to sum 2 (array begins with 0, and first column isn't counted (fieldnames)
     *
     * @param int $line
     * @param mixed $errors (array|string)
     * @access protected
     * @return string
     */
    protected function getLexicalErrors($line, $errors) {
        $ret = '';
        if(is_array($errors)) {
            foreach ($errors as $column) {
                //Search the index of the column
                $index = array_search($column, $this->_columnIndexes);
                if($index !== false ) {
                    $ret.= 'Column: ' . $column . ', ' . $this->_validators[$index]->getErrorMsg($this->_rows[($line - 1)][$index]) . "\n";
                }
                else {
                    //This case should never happen, just for debugging purposes
                    $ret .= 'Unknown error found at column' . $column . "\n";
                }
            }
        } else {
            $ret .= $errors . "\n";
        }
        return $ret;
    }

    /**
     * getErrors collect all the errors and format them in a readable output
     *
     * @access public
     * @return string
     */
    public function getErrors() {
        //Search for the proper column index, currently can be: sku or id
        $column_key = array_search('sku', $this->_columnIndexes);
        if($column_key === false) {
            $column_key = array_search('id', $this->_columnIndexes);
        }
        $ret = '';
        //$place = number of line in case of lexical analysis, and name of column for semantic
        foreach ($this->_errors as $place => $errors) {
            //Initialization errors
            if(is_numeric($place) && $place === 0) {
                $ret.= $errors . "\n";
            //Lexical errors
            } else if(is_numeric($place)) {
                $ret.= 'Error found at item ' . $this->_rows[$place - 1][$column_key] . ':' . "\n";
                $ret.= $this->getLexicalErrors($place, $errors);
            } else {
                //Semantic errors
                $ret.= 'Error found at column ' . $place . "\n";
                $ret.= $this->_validators[$place]->getErrorMsg($errors);
            }
        }
        return $ret;
    }

    /**
     * getWarnings retrieve all the warnings in a readable output
     *
     * @access public
     * @return string
     */
    public function getWarnings() {
        $warnings = '';
        foreach ($this->_validators as $key => $validator) {
            $warns = $validator->getWarnings();
            if(!$warns) {
                continue;
            } else {
                $warnings .= $warns;
            }
        }
        return $warnings;
    }

    /**
     * array_merge_multi Convert multidimensional array into a simple one by merging it's values
     *
     * @param $array multidimensional array
     * @param $vals empty array
     * @return array with all values
     */
    protected function array_merge_multi($array) {
        $vals = array();
        /*foreach ($array as $key => $value) {
            if (is_array($value)) {
                $vals = array_merge($vals, $value);
            }else{
                $vals[] = $value;
            }
        }*/
        $nelems = sizeOf($array);
        for($i = 0; $i < $nelems; $i++) {
            $nelem = sizeOf($array[$i]);
            for($j = 0; $j < $nelem; $j++) {
                $vals[] = $array[$i][$j];
            }
        }
        return $vals;
    }

    /*
     * customSku If it's a customSku site (multi-brands store), generate a new sku by concatenating: "$BRAND_$SKU", to avoid collisions between brands
     * If unable to find brand column or not a customSite, return the original sku
     * TBD: Should we force to provide the brand if it's a custom site?
     *
     * @param $data array row of the CSV
     * @param $sku string
     * @return string (sku|brand_sku)
     *
     */
    protected function customSku($data, $sku) {
        if($this->_customSite) {
            if($this->_brandIndex !== false) {
                //Make Skuable :)
                $brand = self::skuableBrand($data[$this->_brandIndex]) ?: 'Unknown';

                //Ensure the SKU doesn't already contain the brand
                $sku = strpos(self::skuableBrand($sku), self::skuableBrand($data[$this->_brandIndex]) ?: 'Unknown') === false ? $brand . '_' . $sku : $sku;
            } //else error, a brand should be present for custom sites, but the sku might already contain the brand...
            else $this->_customSite = false;    //if couldn't find the brand, deactivate the flag
        }

        return $sku;
    }

    /**
     * customSimplesSkus
     * Append the brand to the sku list of the simples_skus field
     * Only for the customSites
     *
     * @param mixed $data
     * @param mixed $value
     * @access protected
     * @return void
     */
    protected function customSimplesSkus(&$data) {
        //If the flag is not active, we don't have to change the skus
        if(!$this->_customSite) {
            return;
        }

        $simples_skus = array_search('simples_skus', $this->_columnIndexes);
        $key = array_keys($data['simples_skus']);
        $size = sizeOf($key);

        for ($i = 0; $i < $size; $i++) {
            $marca = isset($data['marca']) ? self::skuableBrand($data['marca'][$i]) : self::skuableBrand($data['brand'][$i]);
            //Append the brand prefix to the name (just in case it's not already present)
            //Trim element because some clever client just don't know how to fill an excel correctly !
            array_walk($data['simples_skus'][$key[$i]], array($this, "createCustomSku"), $marca);
            //Update the row data, with the corrected names
            $this->_rows[$i][$simples_skus] = implode($data['simples_skus'][$i], ', ');
        }
    }

    /**
     * createCustomSku, called in array_walk of customSimplesSkus
     * Append the brand to the sku list of the simples_skus field
     *
     * @param mixed $element of array
     * @param mixed $key
     * @param mixed $brand
     * @access protected
     * @return void
     */
    protected function createCustomSku(&$element, $key, $brand){
        $element = strpos($brand, self::skuableBrand($element)) === false ? $brand . '_' .  trim($element) : trim($element);
    }


    /**
     * drop_position, called in array_walk of semantic category_ids
     * Drops position from category id's list
     *
     * @param mixed $element of array
     * @param mixed $key
     * @access protected
     * @return void
     */
    protected function drop_position(&$element, $key){
        list($cat, $pos) = explode('::', $element);
        $element = $cat;
    }

    /**
     * parseFirstRow
     * Check that the column names aren't duplicated
     * Ensure all required fields are present
     * Create the instances of each validator.
     * Set the brandIndex flag, if the field is present
     * This code should be execute just once, so we set a flag to avoid unnecesary repetitions.
     *
     * @param array $data
     * @access protected
     * @return bool
     */
    protected function parseFirstRow(array $data) {
        if($this->_parsedFirstLine) {
            return true;
        }
        $valid = true;
        //Clear the data
        $data = array_filter(array_map('trim', array_map('strtolower', $data)));

        //Ensure that there aren't duplicated columns
        $dupes = array_diff_key($data, array_unique($data));
        if(!empty($dupes)) {
            $this->_errors[] = sprintf('The following columns are duplicated on the CSV: "%s".', implode($dupes, '", "'));
            $valid = false;
        }

        //Ensure all required columns are present
        if($valid &&
            //The number of columns is lower than the required fields, we don't need to keep checking, some columns are missing.
            (count($data) < count($this->_requiredFields) ||
            //The number of optional fields must match with the number of fields that are not required, otherwise something is missing.
            count(array_diff($data, $this->_requiredFields)) !== (count($data) - count($this->_requiredFields)) ||
            //If the operation is an import, either categories or category_ids must be present
            ($this->_profile == 'import' && !(in_array('categories', $data) || in_array('category_ids', $data))) ||
            //If it's a custom site, either brand or marca must be present
            ($this->_customSite && !(in_array('brand', $data) || in_array('marca', $data)))
        )
        ) {

                $required = implode(array_diff($this->_requiredFields, $data), '", "');
                if($this->_profile == 'import' && !in_array('category_ids', $data) && !in_array('categories', $data)) {
                    if($required) {
                        $required .= '" and "categories" or "category_ids';
                    } else {
                        $required = 'categories" or "category_ids';
                    }
                }
                if($this->_customSite == 'import' && !(in_array('brand', $data) || in_array('marca', $data))) {
                    if($required) {
                        $required .= '" and "brand" or "marca';
                    } else {
                        $required = 'brand" or "marca';
                    }
                }
                $this->_errors[] = sprintf('The following columns are missing on the CSV: "%s".', $required);
                $valid = false;
        }

        if($valid) {
            //Instantiate all the lexical validators
            foreach ($data as $key => $value) {
                $this->_validators[$key] = new ValidatorContext('lexical', $value, $this->_profile);
                $this->_columnIndexes[$key] = $value;

                //Save the brand index, needed for the custom sites
                //The brand can be in english or in spanish
                //TODO: What if both columns are present in the CSV?
                if($value == 'brand' || $value == 'marca') {
                    $this->_brandIndex = $key;
                }
            }
        }

        $this->_parsedFirstLine = true;
        return $valid;
    }

    public static function getDelimiter($file) {
        $delimiter = false;
        $line = '';
        if($f = fopen($file, 'r')){
            $line = fgets($f); // read until first newline
            fclose($f);
        }
        if(strpos($line, ';') !== FALSE && strpos($line, ',') === FALSE) {
            $delimiter = ';';
        } else if(strpos($line, ',') !== FALSE && strpos($line, ';') === FALSE) {
            $delimiter = ',';
        } else {
            die('Unable to find the CSV delimiter character. Make sure you use "," or ";" as delimiter and try again.');
        }
        return $delimiter;
    }
    /*
     * Perform the lexical analysis over the CSV
     * Iterate over the csv file and exit if an error is found
     *
     * @param $file string filename of the csv
     * @return bool whether the file is valid or not
     */
    protected function lexical($file) {
        if (!file_exists($file))  {
            return false;
        } else {
            $delimiter = self::getDelimiter($file);
        }

        $parsed = false;
        $handle = fopen($file, 'r');

        //line number count
        $i = 0;
        //For each row
        while(($data = fgetcsv($handle, 0, $delimiter)) !== FALSE) {
            $valid = true;
            $errors = array();

            //First row
            if($i++ == 0) {
                $valid &= $this->parseFirstRow($data);
                if(!$valid) {
                    break;
                }
                //Read second line
                $data = fgetcsv($handle, 0, $delimiter);
            }

            $num_columns = sizeOf($this->_columnIndexes);
            //For each column
            foreach ($data as $key => $value) {

                //Skip all columns without header
                if($key >= $num_columns) {
                    break;
                }

                $value = trim($value);
                //Convert the sku, if it's a custom site
                if($this->_columnIndexes[$key] == 'sku') {
                    //Check for custom skus (BRAND_SKU)
                    $value = $this->customSku($data, $value);
                }
                //Validate
                $errors[$this->_columnIndexes[$key]] = $this->_validators[$key]->validate($value);

                //Correct the input, just if it has been changed by the validator
                if ($value !== $data[$key]) {
                    $data[$key] = $value;
                }
                $valid = $valid && $errors[$this->_columnIndexes[$key]];
            }

            //Save all read rows, filtering out the trailing empty columns
            $this->_rows[] = array_slice($data, 0, $num_columns);

            //If any error was found, exit
            if(!$valid) {
                $filtered_errors = array_keys($errors, false);
                if(count($filtered_errors) > 0) {
                    $this->_errors[$i] = $filtered_errors;
                }
                break;
            }

        }
        fclose($handle);

        return $valid;
    }

    /*
     * Receive the tokens obtained on the lexical phase and performs the semantic analysis
     *
     * @param $input mixed array
     * @return bool whether the semantic analysis passed or not
     */
    protected function semantic($input) {
        $this->mysqli = new mysqli($this->_dbConfig->host, $this->_dbConfig->username, $this->_dbConfig->password, $this->_dbConfig->dbname);
        $this->mysqli->set_charset("utf8");
        /* check connection */
        if ($this->mysqli->connect_errno) {
            $this->_errors[] = sprintf('Connect failed: %s', $this->mysqli->connect_error);
            $valid = false;
        }
        mysqli_set_charset($this->mysqli, "utf8");

        //If Simples-Configurables module is not active, we need to create the new column: super_attribute_pricing
        //But only if the type and the simples_skus are set
        if(!$this->_isActiveSCModule && isset($input['type']) && isset($input['simples_skus'])) {
            $input['super_attribute_pricing'] = array();
        }

        if(!empty($input['name']) && !empty($input['image']) && empty($input['image_label'])) {
            $input['image_label'] = str_replace(',', '', $input['name']);
        }

        $valid = true;
        $errors = array();
        foreach ($input as $key => $value) {
            switch ($key) {
                //This column require row-by-row check plus the unique array
            case 'sku':
                $vals = array_unique(array_merge($value));
                //Filter out skus that will be imported
                $vals = array_diff($vals, $this->getSkusImport());
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate($imageData = array('unique' => $vals, 'input' => $input));
                break;
                //Columns that should be directly skipped (no validation is required):
            case 'name':
            case 'status':
            case 'description':
            case 'short_description':
            case 'meta_title':
            case 'meta_description':
            case 'meta_keywords':
                $errors[$key] = true;
                break;

                //Columns that doesn't require a array_merge_multi (just one value per field)
            case 'tax_class_id':
            case 'attribute_set':
                //Get simplified array list
                $vals = array_unique(array_merge($value));
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate($vals);
                break;

                //Columns that might have several comma-separated values, array_merge_multi required
            case 'store':
                $vals = array_unique(array_filter($this->array_merge_multi($value)));
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate($vals);
                break;
            case 'categories':
                //Bypass semantic categories validator if newCategories flag is enabled
                if($this->_newCategories) {
                    $errors[$key] = true;
                } else {
                    //Get simplified array list
                    $vals = array_unique(array_filter($this->array_merge_multi($value)));
                    $stores = isset($input['store']) ? array_unique(array_filter($this->array_merge_multi($input['store']))) : array();
                    $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                    $errors[$key] = $this->_validators[$key]->validate($catInput = array('unique' => $vals, 'stores' => $stores));
                }
                break;
            case 'category_ids':
                //Get simplified array list
                $vals = array_unique(array_filter($this->array_merge_multi($value)));
                array_walk($vals, array($this, 'drop_position'));
                $vals = array_unique($vals);
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate($vals);
                break;
                //This column requie a row-by-row check plus the array_merge_multi
            case 'simples_skus':
                //Check for custom skus (BRAND_SKU)
                $this->customSimplesSkus($input);
                $vals = $this->array_merge_multi($value);

                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate(($sData = array('input' => $input, 'merged' => $vals, 'imported' => $this->getSkusImport())));
                break;
                //This columns require a row-by-row check
            case 'configurable_attributes':
            case 'qty':
            case 'weight':
            case 'type':
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate($input);
                break;
            case 'marca':
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->_customSite);
                $errors[$key] = $this->_validators[$key]->validate($input);
                break;
            case 'price':
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->_isActiveSCModule);
                $errors[$key] = $this->_validators[$key]->validate($input);
                break;
            case 'visibility':
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate($input);
                //Add the new/corrected visibility with the default values assigned
                $visIndex = array_search('visibility', $this->_columnIndexes);
                foreach ($this->_rows as $l => $product) {
                    $this->_rows[$l][$visIndex] = $input['visibility'][$l];
                }
                break;

                //This column require row-by-row check plus the unique array (array_merge_multi)
            case 'image':
                $vals = array_unique($this->array_merge_multi($value));
                //If the Simples-Configurables module is active, the configurable product can leave the image field empty
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->_isActiveSCModule);
                //Generate the array of data that will be passed to the validator
                $imageData = array('unique' => $vals, 'input' => $input, 'customSite' => $this->_customSite);
                $errors[$key] = $this->_validators[$key]->validate($imageData);
                //If it's a customSite, replace the rows with the new values generated on the validator
                $iIndex = array_search('image', $this->_columnIndexes);
                if($this->_customSite) {
                    foreach($this->_rows as $l => $p) {
                        $this->_rows[$l][$iIndex] = implode($imageData['input']['image'][$l], ', ');
                    }
                }
                unset($imageData); //Remove big array from memory
                break;

                //This validator might add a new column for each configurable product
            case 'super_attribute_pricing':
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile);
                $errors[$key] = $this->_validators[$key]->validate($input);
                //If any new data has been computed
                if(count($input['super_attribute_pricing']) > 0) {
                    $index = count($this->_columnIndexes);
                    $this->_columnIndexes[$index] = 'super_attribute_pricing';
                    //Add the new column to the array
                    foreach ($this->_rows as $line => $val) {
                        $this->_rows[$line][$index] = isset($input['super_attribute_pricing'][$line]) ? $input['super_attribute_pricing'][$line] : '';
                    }
                }
                break;
           case 'image_label':
                //If any data on the column
               if(count($input['image_label']) > 0) {
                   $index = count($this->_columnIndexes);
                   //If image_label already exists, we shouldn't override its content
                    if(array_search('image_label', $this->_columnIndexes) === false) {
                        $addLabel = true;
                    } else {
                        $addLabel = false;
                    }
                    $this->_columnIndexes[$index] = 'small_image_label';
                    $this->_columnIndexes[$index+1] = 'thumbnail_label';
                    if($addLabel) $this->_columnIndexes[$index+2] = 'image_label';
                    //Add the new column to the array
                    foreach ($this->_rows as $line => $val) {
                        $this->_rows[$line][$index] = isset($input['image_label'][$line]) ? $input['image_label'][$line] : '';
                        $this->_rows[$line][$index+1] = isset($input['image_label'][$line]) ? $input['image_label'][$line] : '';
                        if($addLabel) $this->_rows[$line][$index+2] = isset($input['image_label'][$line]) ? $input['image_label'][$line] : '';
                    }
                }
                $errors[$key] = true;
                break;
                // This validator is for the actualization of category, to check if category_id is unique
            case 'category_id':
                $vals = array_unique(array_merge($value));
                $this->_validators[$key] = new ValidatorContext('semantic', $key, $this->_profile, $this->mysqli);
                $errors[$key] = $this->_validators[$key]->validate($imageData = array('unique' => $vals, 'input' => $input));
                break;

                //Bypass validation of unknown fields
            default:
                $errors[$key] = true;
            }
            $valid = $valid && $errors[$key];

            if(!$valid) {
                break;
            }
        }

        $this->mysqli->close();

        if (!$valid) {
            //Filter the errors removing the correct fields
            foreach (array_keys($errors, false) as $key) {
                $this->_errors[$key] = $this->_validators[$key]->getErrors();
            }
        }
        return $valid;

    }

    /*
     * Wrapper method that performs the specified analysis
     * Keep track of the time spent on the analysis
     *
     * @param $type (lexical|semantic)
     * @param $args mixed
     * @return bool
     */
    public function analyze($type, $args) {
        $passed = false;
        if(method_exists($this, $type)){

            $Analyzer = microtime(true);
            $result = $this->$type($args);
            $time_taken = microtime(true) - $Analyzer;

            if ($result) {
                $this->_results .= 'The ' . $type . ' analysis has successfully passed all validations for the ' . $this->getProfile() . ' profile.' . "\n";
            }
            $this->_results .= 'Time taken: ' . $time_taken . ' seconds' . "\n";
        }
        return $result;
    }

    /*
     * Make a brand skuable, which is LOWER ans without space
     * TODO : Maybe go a little further and check for accent, tilde, etc
     *
     * @param $string ($string)
     * @return string
     */
    public static function skuableBrand($string) {
        $cleanBrand = strtr($string, 'ŠŽšžŸÀÁÂÃÄÅÇÈÉÊËÌÍÎÏÑÒÓÔÕÖØÙÚÛÜÝàáâãäåçèéêëìíîïñòóôõöøùúûüýÿ', 'SZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy');        
        $cleanBrand = preg_replace('/[^0-9a-z_]+/i', '', $cleanBrand);        
        return strtoupper($cleanBrand);
    }
}
